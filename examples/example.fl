# symbol on right edge of name: some kind of definition/declaration
# symbol on left edge: some kind of location lookup 
# bare name: variable value lookup

# start definition of function f
f^
    # x$ # declares variable x without pushing its location to the stack
    $x$  # declare function-scoped variable x and pushes its location to the stack
    ->   # pops the location of x, then pops a value, which is the first func arg, and assigns it into x
    x !print
    
    [ # opens a new evaluation stack (to protect us from badly-written functions)
    x ^f2 call_eval # call f2 with argument x and evaluate return value onto stack
    # using "call" instead would not evaluate return value onto stack
    $x -> # assign call return value on stack into x
    ]~ # closes the new evaluation stack
    
    y$
    
    x !print
    "Hello, world!" !printstr  # strings ending witout * are reference strings and can be mutated, affecting later evaluations of the same string literal.
    "Hello, world!"* !printstr # strings ending with a * are value strings and the interpreter needs to make a copy of them whenever they're evaluated. the resulting array value is mutable but disjoint from the original backing array.
    
    # :yes is label lookup
    # (either looks at most recent definition of "yes:", or looks for next definition of "yes:")
    x :yes if_goto
    y :yes2 if_goto
    :no goto
    
    yes:
        17 return
    yes2:
        :out goto
    no:
        659 return
    
    
    out:
    # functions return 0 by default
^^ # end of function


f2^

^^

14 ^f call_eval

[ 15 6 2052 ] $test$ -> # build an array with three elements

test # push a the array onto the stack by value (stacks are copied by reference, so this doesn't allocate new heap memory)
$test 1 @ -> # assign test[1] = test so it references itself
# test !print # print out test (crashes after printing a bunch of "[15, [15, [15, [15, " junk, infinite descent into the recursive array)

0 $test 1 @ ->

test :: # push a cloned copy of the array instead of by reference (note: cloning is shallow!)
$test 1 @ ->

test !print

# char evaluation: "a" !first

"asdf" !first !print
"asdf" !last !print

[ "asdf" !first ] !printstr
[ "asdf" !last ] !printstr

( 0x20 == ( " " !first ) ) !print
( 0x20 == ( "x" !first ) ) !print

'a' !print
'f' !print

[ 'a' ] !printstr
[ 'f' ] !printstr

( 0x20 == ' ' ) !print
( 0x20 == 'x' ) !print
